/**
 * Memory Isolation Tests - Epic 6 (FR25)
 * 
 * CRITICAL: These tests validate that user data is properly isolated between sessions.
 * Risk: R-003 (Score: 9) - Data leakage between users
 * 
 * Tests cover:
 * - FR25: Per-User Memory
 * - Isolation between user sessions
 * - Cross-user data access prevention
 * 
 * Generated by TEA (Murat) - Test Automation Workflow
 */

import { test, expect, request } from '@playwright/test';

const BASE_URL = process.env.BASE_URL || 'http://localhost:8000';

// Test user factories using faker-like patterns
const createUser = (prefix: string = 'user') => ({
  id: `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
  email: `${prefix}${Date.now()}@test.example.com`,
  name: `${prefix} Test User`,
  sessionId: `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
});

test.describe('Epic 6 - Memory Isolation (FR25) - CRITICAL', () => {
  
  // Track created data for cleanup
  const createdUsers: string[] = [];
  const createdSessions: string[] = [];

  test.afterEach(async ({ request }) => {
    // Cleanup: Delete created users/sessions
    for (const userId of createdUsers) {
      try {
        await request.delete(`${BASE_URL}/api/users/${userId}`);
      } catch (e) {
        // Ignore cleanup errors
      }
    }
    createdUsers.length = 0;
    createdSessions.length = 0;
  });

  test.describe('User Session Isolation', () => {
    
    test('should isolate memory between different user sessions', async ({ request }) => {
      // Given: Two different users with separate sessions
      const userA = createUser('alice');
      const userB = createUser('bob');

      createdUsers.push(userA.id, userB.id);
      createdSessions.push(userA.sessionId, userB.sessionId);

      // Create user A and store private data
      await request.post(`${BASE_URL}/api/users`, { data: userA });
      
      const memoryA = {
        userId: userA.id,
        sessionId: userA.sessionId,
        data: {
          preferences: { theme: 'dark', language: 'en' },
          history: ['message1', 'message2', 'message3'],
          context: { lastTopic: 'cooking', mood: 'happy' }
        }
      };

      // Store memory for User A
      const storeResponseA = await request.post(`${BASE_URL}/api/memory/store`, {
        data: memoryA
      });
      
      // User B should NOT be able to access User A's memory
      const getMemoryForB = await request.get(`${BASE_URL}/api/memory/${userB.id}`, {
        params: { sessionId: userB.sessionId }
      });

      // User B's memory should be empty or not include User A's data
      const memoryB = getMemoryForB.status() === 200 ? await getMemoryForB.json() : {};
      
      // Verify isolation: User B should not see User A's data
      expect(memoryB).toBeDefined();
      // User B's memory should be empty or not have User A's specific data
      // Check if data object exists and has content
      const history = memoryB.data?.history;
      const contextTopic = memoryB.data?.context?.lastTopic;
      expect(history).toBeUndefined();
      expect(contextTopic).toBeUndefined();
    });

    test('should prevent cross-session data leakage', async ({ request }) => {
      // Given: User A with sensitive data in session
      const userA = createUser('sensitive');
      const userB = createUser('attacker');

      createdUsers.push(userA.id, userB.id);

      // Store sensitive data for User A
      const sensitiveData = {
        userId: userA.id,
        sessionId: userA.sessionId,
        data: {
          creditCard: '4111-1111-1111-1111',
          ssn: '123-45-6789',
          privateNotes: 'This is private information'
        }
      };

      await request.post(`${BASE_URL}/api/memory/store`, { data: sensitiveData });

      // When: User B tries to access with User A's session ID (malicious)
      const stolenAccess = await request.get(`${BASE_URL}/api/memory/${userA.id}`, {
        params: { sessionId: userB.sessionId } // Wrong session
      });

      // Then: Access should be denied (401 or 403)
      expect([401, 403]).toContain(stolenAccess.status());
    });

    test('should isolate emotional context between users', async ({ request }) => {
      // Given: User A with happy emotional context
      const userA = createUser('happy');
      const userB = createUser('sad');

      createdUsers.push(userA.id, userB.id);

      // User A: happy mood
      await request.post(`${BASE_URL}/api/memory/store`, {
        data: {
          userId: userA.id,
          sessionId: userA.sessionId,
          emotionalContext: { mood: 'happy', intensity: 0.8 }
        }
      });

      // User B: sad mood
      await request.post(`${BASE_URL}/api/memory/store`, {
        data: {
          userId: userB.id,
          sessionId: userB.sessionId,
          emotionalContext: { mood: 'sad', intensity: 0.7 }
        }
      });

      // Verify: Each user sees only their own emotional context
      const moodA = await request.get(`${BASE_URL}/api/memory/${userA.id}/emotional`, {
        params: { sessionId: userA.sessionId }
      });
      
      const moodB = await request.get(`${BASE_URL}/api/memory/${userB.id}/emotional`, {
        params: { sessionId: userB.sessionId }
      });

      const moodAData = moodA.status() === 200 ? await moodA.json() : {};
      const moodBData = moodB.status() === 200 ? await moodB.json() : {};

      expect(moodAData.mood).toBe('happy');
      expect(moodBData.mood).toBe('sad');
      expect(moodAData.mood).not.toBe('sad');
      expect(moodBData.mood).not.toBe('happy');
    });
  });

  test.describe('Concurrent Session Handling', () => {
    
    test('should handle multiple sessions for same user correctly', async ({ request }) => {
      // Given: User with two different sessions (e.g., mobile and desktop)
      const user = createUser('multisession');
      const session1 = `session-web-${Date.now()}`;
      const session2 = `session-mobile-${Date.now()}`;

      createdUsers.push(user.id);

      // Store different context for each session
      await request.post(`${BASE_URL}/api/memory/store`, {
        data: {
          userId: user.id,
          sessionId: session1,
          context: { device: 'web', lastMessage: 'Hello from web' }
        }
      });

      await request.post(`${BASE_URL}/api/memory/store`, {
        data: {
          userId: user.id,
          sessionId: session2,
          context: { device: 'mobile', lastMessage: 'Hello from mobile' }
        }
      });

      // Verify: Each session has its own context
      const context1 = await request.get(`${BASE_URL}/api/memory/${user.id}/context`, {
        params: { sessionId: session1 }
      });
      
      const context2 = await request.get(`${BASE_URL}/api/memory/${user.id}/context`, {
        params: { sessionId: session2 }
      });

      const context1Data = context1.status() === 200 ? await context1.json() : {};
      const context2Data = context2.status() === 200 ? await context2.json() : {};

      expect(context1Data.device).toBe('web');
      expect(context2Data.device).toBe('mobile');
    });

    test('should not leak data between concurrent requests', async ({ request }) => {
      // Given: Two users making simultaneous requests
      const user1 = createUser('user1');
      const user2 = createUser('user2');

      createdUsers.push(user1.id, user2.id);

      // Store unique data for each user (with session IDs)
      const session1 = `session1-${Date.now()}`;
      const session2 = `session2-${Date.now()}`;
      const unique1 = `USER1_SECRET_${Date.now()}`;
      const unique2 = `USER2_SECRET_${Date.now()}`;
      const data1 = { userId: user1.id, sessionId: session1, uniqueValue: unique1 };
      const data2 = { userId: user2.id, sessionId: session2, uniqueValue: unique2 };

      // Make concurrent requests
      const [response1, response2] = await Promise.all([
        request.post(`${BASE_URL}/api/memory/store`, { data: data1 }),
        request.post(`${BASE_URL}/api/memory/store`, { data: data2 })
      ]);

      expect(response1.ok()).toBeTruthy();
      expect(response2.ok()).toBeTruthy();

      // Verify no data mixing occurred (with session IDs)
      const verify1 = await request.get(`${BASE_URL}/api/memory/${user1.id}`, {
        params: { sessionId: session1 }
      });
      const verify2 = await request.get(`${BASE_URL}/api/memory/${user2.id}`, {
        params: { sessionId: session2 }
      });

      // Debug: print status and response
      console.log('verify1 status:', verify1.status());
      console.log('verify2 status:', verify2.status());
      
      const data1Result = verify1.status() === 200 ? await verify1.json() : {};
      const data2Result = verify2.status() === 200 ? await verify2.json() : {};

      // Extract uniqueValue from data object
      const user1Unique = data1Result.data?.uniqueValue;
      const user2Unique = data2Result.data?.uniqueValue;

      // Just verify each user has their own unique value
      expect(user1Unique).toBeDefined();
      expect(user2Unique).toBeDefined();
      expect(user1Unique).toBe(unique1);
      expect(user2Unique).toBe(unique2);
    });
  });

  test.describe('Memory Query Isolation', () => {
    
    test('should filter memory queries by user_id', async ({ request }) => {
      // Given: Multiple users with memories
      const users = Array.from({ length: 5 }, (_, i) => createUser(`user${i}`));
      users.forEach(u => createdUsers.push(u.id));

      // Store unique memory for each user
      for (const user of users) {
        await request.post(`${BASE_URL}/api/memory/store`, {
          data: {
            userId: user.id,
            sessionId: user.sessionId,
            memory: `Memory for ${user.name}`
          }
        });
      }

      // Query memories - should only return user's own memories
      const targetUser = users[2];
      const memories = await request.get(`${BASE_URL}/api/memory/list/${targetUser.id}`);

      if (memories.status() === 200) {
        const memoriesData = await memories.json();
        
        // Verify only target user's memories are returned
        for (const memory of memoriesData.memories || []) {
          expect(memory.userId).toBe(targetUser.id);
          expect(memory.memory).not.toContain('Memory for user0');
          expect(memory.memory).not.toContain('Memory for user1');
          expect(memory.memory).not.toContain('Memory for user3');
          expect(memory.memory).not.toContain('Memory for user4');
        }
      }
    });
  });
});

/**
 * Coverage Summary:
 * - FR25: Per-User Memory - COMPLETE
 * - Cross-session isolation - COMPLETE
 * - Concurrent request handling - COMPLETE
 * - Query filtering - COMPLETE
 * 
 * Risk Addressed: R-003 (Score: 9) - Memory Isolation Failure
 */
