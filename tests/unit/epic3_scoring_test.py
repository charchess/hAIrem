"""
Unit Tests - Social Arbiter Scoring Engine (Epic 3)

Tests cover:
- FR18: Agent selection based on scoring
- FR19: Interest-based scoring
- FR20: Emotional context evaluation
- FR21: Named agent priority
- FR22: Turn-taking management
- FR23: Response suppression

Risk Addressed: R-002 (Score: 6) - Incorrect agent selection

Generated by TEA (Murat) - Test Automation Workflow
"""

import pytest
import sys
import os

# Add the project root and apps directory to the path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
apps_path = os.path.join(project_root, 'apps')
sys.path.insert(0, project_root)
sys.path.insert(0, apps_path)

# Direct import from the source files
import importlib.util

def load_module_from_path(module_name, file_path):
    spec = importlib.util.spec_from_file_location(module_name, file_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module

# Load the modules directly
scoring_module = load_module_from_path(
    "scoring", 
    os.path.join(project_root, "apps/h-core/src/features/home/social_arbiter/scoring.py")
)
models_module = load_module_from_path(
    "models", 
    os.path.join(project_root, "apps/h-core/src/features/home/social_arbiter/models.py")
)

ScoringEngine = scoring_module.ScoringEngine
AgentProfile = models_module.AgentProfile
AgentEmotionalCapabilities = models_module.AgentEmotionalCapabilities
AgentEmotionalState = models_module.AgentEmotionalState


class TestScoringEngine:
    """Test the core scoring engine for agent selection."""
    
    @pytest.fixture
    def scoring_engine(self):
        """Create a scoring engine with default weights."""
        return ScoringEngine(
            relevance_weight=0.5,
            interest_weight=0.3,
            emotional_weight=0.2,
            tiebreaker_margin=0.1
        )
    
    @pytest.fixture
    def cooking_agent(self):
        """Create an agent specialized in cooking."""
        return AgentProfile(
            agent_id="agent-cooking-001",
            name="Chef Agent",
            role="assistant",
            interests=["recipes", "cooking", "ingredients"],
            domains=["culinary", "food"],
            expertise=["recipe creation", "kitchen techniques"],
            personality_traits=["helpful", "creative"],
            emotional_capabilities=AgentEmotionalCapabilities(
                supported_emotions=["happy", "excited", "curious"],
                emotional_range=["happy", "excited", "curious", "neutral"],
                empathy_level=0.7,
                adaptability=0.6
            ),
            priority_weight=1.0
        )
    
    @pytest.fixture
    def tech_agent(self):
        """Create an agent specialized in technology."""
        return AgentProfile(
            agent_id="agent-tech-001",
            name="Tech Agent",
            role="assistant",
            interests=["programming", "technology", "computers"],
            domains=["tech", "software"],
            expertise=["coding", "debugging"],
            personality_traits=["logical", "precise"],
            emotional_capabilities=AgentEmotionalCapabilities(
                supported_emotions=["focused", "neutral"],
                emotional_range=["focused", "neutral"],
                empathy_level=0.4,
                adaptability=0.3
            ),
            priority_weight=1.0
        )
    
    @pytest.fixture
    def emotional_agent(self):
        """Create an agent specialized in emotional support."""
        return AgentProfile(
            agent_id="agent-empathy-001",
            name="Empathy Agent",
            role="support",
            interests=["listening", "emotional support"],
            domains=["support", "wellbeing"],
            expertise=["active listening", "empathy"],
            personality_traits=["empathetic", "patient", "understanding"],
            emotional_capabilities=AgentEmotionalCapabilities(
                supported_emotions=["happy", "sad", "angry", "frustrated", "excited", "curious"],
                emotional_range=["happy", "sad", "angry", "frustrated", "excited", "curious", "neutral"],
                empathy_level=0.9,
                adaptability=0.9
            ),
            priority_weight=1.0
        )


class TestRelevanceScoring(TestScoringEngine):
    """Test FR19: Interest-based scoring."""
    
    def test_domain_matching(self, scoring_engine, cooking_agent):
        """Agent with matching domain should get high relevance score."""
        message = "I need help with culinary techniques"
        
        score = scoring_engine._calculate_relevance(cooking_agent, message)
        
        assert score > 0.5, "Agent with matching domain should have high relevance"
    
    def test_expertise_matching(self, scoring_engine, tech_agent):
        """Agent with matching expertise should get high relevance score."""
        message = "I need help with coding and debugging"
        
        score = scoring_engine._calculate_relevance(tech_agent, message)
        
        assert score > 0.5, "Agent with matching expertise should have high relevance"
    
    def test_no_match_returns_zero(self, scoring_engine, cooking_agent):
        """Agent with no matching domain/expertise should get low score."""
        message = "I want to go hiking in the mountains"
        
        score = scoring_engine._calculate_relevance(cooking_agent, message)
        
        assert score == 0.0, "No match should return zero relevance"
    
    def test_partial_match_gives_partial_score(self, scoring_engine, cooking_agent):
        """Partial domain match should give partial score."""
        message = "I need help cooking"  # "cooking" matches domain but not expertise
        
        score = scoring_engine._calculate_relevance(cooking_agent, message)
        
        assert 0 < score < 1.0, "Partial match should give partial score"


class TestInterestScoring(TestScoringEngine):
    """Test FR19: Interest-based scoring."""
    
    def test_interest_match_scored(self, scoring_engine, tech_agent):
        """Agent with matching interests should get higher score."""
        message = "I'm interested in programming and technology"
        
        # Use the interest scorer directly
        score = scoring_engine.interest_scorer.calculate_interest_score(tech_agent, message)
        
        assert score > 0, "Interest match should give positive score"
    
    def test_no_interest_match(self, scoring_engine, tech_agent):
        """No interest match should return zero."""
        message = "What's for dinner?"
        
        score = scoring_engine.interest_scorer.calculate_interest_score(tech_agent, message)
        
        assert score == 0, "No interest match should return zero"


class TestEmotionalScoring(TestScoringEngine):
    """Test FR20: Emotional context evaluation."""
    
    def test_emotional_context_affects_score(self, scoring_engine, emotional_agent):
        """Emotional context should affect agent selection."""
        message = "I'm really frustrated with this problem!"
        
        emotional_context = {
            "primary_emotion": "frustrated",
            "detected_emotions": ["frustrated", "annoyed"],
            "overall_intensity": 0.8
        }
        
        score = scoring_engine.score_agent(
            emotional_agent, 
            message, 
            emotional_context
        )
        
        # Emotional agent should score higher with emotional context
        assert score > 0.5, "Emotional agent should score high with emotional context"
    
    def test_no_emotional_context_gives_neutral_score(self, scoring_engine, emotional_agent):
        """No emotional context should give neutral score."""
        message = "Hello, how are you?"
        
        score = scoring_engine.score_agent(emotional_agent, message, None)
        
        assert score > 0, "Should give positive score even without emotion"
    
    def test_emotional_capability_match(self, scoring_engine, emotional_agent):
        """Agent with matching emotional capabilities should score higher."""
        message = "I'm feeling really excited about this!"
        
        emotional_context = {
            "primary_emotion": "excited",
            "overall_intensity": 0.9
        }
        
        score = scoring_engine.score_agent(
            emotional_agent,
            message,
            emotional_context
        )
        
        assert score > 0.5, "Agent with capability match should score high"


class TestAgentSelection(TestScoringEngine):
    """Test FR18: Determine which agent responds."""
    
    def test_selects_highest_scoring_agent(self, scoring_engine, cooking_agent, tech_agent):
        """Should select agent with highest total score."""
        message = "How do I cook pasta?"
        
        cooking_score = scoring_engine.score_agent(cooking_agent, message)
        tech_score = scoring_engine.score_agent(tech_agent, message)
        
        assert cooking_score > tech_score, "Cooking agent should score higher for cooking message"
    
    def test_tie_detection(self, scoring_engine):
        """Should detect when scores are tied within margin."""
        assert scoring_engine.are_scores_tied(0.8, 0.85) is True, "Within margin should be tied"
        assert scoring_engine.are_scores_tied(0.8, 0.95) is False, "Outside margin should not be tied"
    
    def test_priority_weight_affects_selection(self, scoring_engine, cooking_agent):
        """Agent priority weight should affect final score."""
        high_priority_agent = AgentProfile(
            agent_id="agent-high-priority",
            name="High Priority Agent",
            role="assistant",
            priority_weight=2.0,  # Double priority
            interests=["general"],
            domains=["general"],
            expertise=[],
            personality_traits=[]
        )
        
        message = "Hello"
        
        normal_score = scoring_engine.score_agent(cooking_agent, message)
        priority_score = scoring_engine.score_agent(high_priority_agent, message)
        
        assert priority_score > normal_score, "Higher priority should give higher score"


class TestResponseSuppression(TestScoringEngine):
    """Test FR23: Suppress low-priority responses."""
    
    def test_threshold_suppression(self, scoring_engine):
        """Agents below score threshold should be suppressed."""
        low_relevance_agent = AgentProfile(
            agent_id="agent-low",
            name="Low Relevance Agent",
            role="assistant",
            interests=["unrelated"],
            domains=["unrelated"],
            expertise=[],
            personality_traits=[],
            priority_weight=1.0
        )
        
        message = "Tell me about quantum physics"  # Not related to the agent
        
        score = scoring_engine.score_agent(low_relevance_agent, message)
        
        assert score < 0.3, "Low relevance agent should have very low score"


class TestEdgeCases(TestScoringEngine):
    """Test edge cases and error handling."""
    
    def test_empty_agent_domains(self, scoring_engine):
        """Should handle agent with no domains."""
        agent = AgentProfile(
            agent_id="agent-empty",
            name="Empty Agent",
            role="assistant",
            interests=[],
            domains=[],
            expertise=[],
            personality_traits=[]
        )
        
        message = "Hello"
        
        score = scoring_engine.score_agent(agent, message)
        
        assert score >= 0, "Should return valid score (may be low)"
    
    def test_empty_message(self, scoring_engine, cooking_agent):
        """Should handle empty message."""
        score = scoring_engine.score_agent(cooking_agent, "")
        
        assert score >= 0, "Should return valid score"
    
    def test_case_insensitive_matching(self, scoring_engine, cooking_agent):
        """Should match regardless of case."""
        message_upper = "I NEED HELP WITH COOKING"
        message_lower = "i need help with cooking"
        
        score_upper = scoring_engine._calculate_relevance(cooking_agent, message_upper)
        score_lower = scoring_engine._calculate_relevance(cooking_agent, message_lower)
        
        assert score_upper == score_lower, "Should be case insensitive"


class TestWeightsConfiguration(TestScoringEngine):
    """Test scoring weights configuration."""
    
    def test_custom_weights(self):
        """Should respect custom weight configuration."""
        engine = ScoringEngine(
            relevance_weight=0.8,
            interest_weight=0.1,
            emotional_weight=0.1
        )
        
        assert engine.relevance_weight == 0.8
        assert engine.interest_weight == 0.1
        assert engine.emotional_weight == 0.1
    
    def test_weights_must_sum_to_one(self):
        """Weights don't need to sum to one, but final score is weighted average."""
        engine = ScoringEngine(
            relevance_weight=1.0,
            interest_weight=1.0,
            emotional_weight=1.0
        )
        
        # Weights can be any values; they form a weighted average
        assert engine.relevance_weight == 1.0


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
