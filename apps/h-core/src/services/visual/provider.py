import json
import logging
import os
import tempfile
import asyncio
from abc import ABC, abstractmethod
from typing import Any

import httpx

logger = logging.getLogger(__name__)

class VisualProvider(ABC):
    """
    Abstract base class for visual generation providers.
    """
    @abstractmethod
    async def generate(self, prompt: str, reference_image: str | None = None, **kwargs: Any) -> str:
        """
        Generate an image and return its URL or a reference to the generated asset.
        
        Args:
            prompt: The text description of the image to generate.
            reference_image: Optional URL or Base64 encoded reference image.
            **kwargs: Additional provider-specific parameters (e.g., style_preset).
            
        Returns:
            The URL (http:// or file://) of the generated image.
        """
        pass

class GoogleImagenProvider(VisualProvider):
    """
    Implementation of VisualProvider for Google Imagen via google-genai SDK.
    """
    def __init__(self, api_key: str | None = None, model: str = None):
        self.api_key = api_key or os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY")
        self.model = model or os.getenv("GOOGLE_IMAGEN_MODEL", "imagen-4.0-fast-generate-001")
        
        if not self.api_key:
            logger.warning("GOOGLE_API_KEY not found. Imagen generation will fail.")
        else:
            logger.info(f"GoogleImagenProvider initialized with model: {self.model}")

    async def generate(self, prompt: str, reference_image: str | None = None, **kwargs: Any) -> str:
        try:
            from google import genai
            from google.genai import types
            
            client = genai.Client(api_key=self.api_key)
            
            # Map kwargs to Imagen config
            aspect_ratio = kwargs.get("aspect_ratio", "1:1")
            # Convert "portrait" / "landscape" keywords if used in prompts
            if "full body" in prompt.lower() or "portrait" in prompt.lower():
                aspect_ratio = "3:4"
            elif "wide" in prompt.lower() or "landscape" in prompt.lower():
                aspect_ratio = "4:3"

            logger.info(f"IMAGEN: Generating with model {self.model} (AR: {aspect_ratio}) prompt: {prompt[:50]}...")
            
            # The SDK call is synchronous, so we run it in an executor
            def _generate():
                response = client.models.generate_images(
                    model=self.model,
                    prompt=prompt,
                    config=types.GenerateImagesConfig(
                        number_of_images=1,
                        aspect_ratio=aspect_ratio,
                        safety_filter_level="BLOCK_ONLY_HIGH"
                    )
                )
                if response.generated_images:
                    return response.generated_images[0].image
                return None

            loop = asyncio.get_running_loop()
            image_obj = await loop.run_in_executor(None, _generate)
            
            if not image_obj:
                raise ValueError("No image generated by Google Imagen")

            # Save to temporary file
            fd, path = tempfile.mkstemp(suffix=".png")
            with os.fdopen(fd, "wb") as tmp:
                image_obj.save(tmp, format="PNG")
            
            # Return local path with file:// scheme
            return f"file://{path}"

        except Exception as e:
            logger.error(f"Google Imagen generation failed: {e}")
            raise

class NanoBananaProvider(VisualProvider):
    """
    Implementation of VisualProvider for the NanoBanana API.
    """
    def __init__(self, api_key: str | None = None, base_url: str | None = None):
        """
        Initialize the NanoBanana provider.
        
        Args:
            api_key: API key for NanoBanana. Defaults to NANOBANANA_API_KEY or NANOBANANA_GEMINI_API_KEY env var.
            base_url: Base URL for NanoBanana API. Defaults to NANOBANANA_BASE_URL env var or port 8000.
        """
        self.api_key = api_key or os.getenv("NANOBANANA_API_KEY") or os.getenv("NANOBANANA_GEMINI_API_KEY")
        self.base_url: str = str(base_url or os.getenv("NANOBANANA_BASE_URL", "http://localhost:8000"))
        
        if not self.api_key:
            logger.warning("NANOBANANA_API_KEY not found in environment.")
        
        logger.info(f"NanoBananaProvider initialized with base_url: {self.base_url}")

    async def generate(self, prompt: str, reference_image: str | None = None, **kwargs: Any) -> str:
        """
        Generate an image using the NanoBanana API.
        """
        endpoint = f"{self.base_url.rstrip('/')}/generate"
        
        payload = {
            "prompt": prompt,
            "style_preset": kwargs.get("style_preset", "general")
        }
        
        if reference_image:
            payload["reference_image"] = reference_image
            
        # Add any other kwargs to payload
        for key, value in kwargs.items():
            if key != "style_preset":
                payload[key] = value

        headers = {
            "Authorization": f"Bearer {self.api_key}" if self.api_key else "",
            "Content-Type": "application/json"
        }

        async with httpx.AsyncClient() as client:
            try:
                # STORY 25.1 LOGGING: Full Image Prompt and Full Response
                safe_payload = payload.copy()
                if "reference_image" in safe_payload:
                    safe_payload["reference_image"] = f"[BASE64_DATA:{len(safe_payload['reference_image'])} chars]"
                logger.info(f"RAW_IMAGE_PROMPT: {json.dumps(safe_payload, indent=2)}")
                
                logger.info(f"Calling NanoBanana API: {endpoint} with prompt: {prompt[:50]}...")
                response = await client.post(endpoint, json=payload, headers=headers, timeout=60.0)
                response.raise_for_status()
                
                data = response.json()
                logger.info(f"RAW_IMAGE_RESPONSE: {json.dumps(data, indent=2)}")
                
                image_url = data.get("url")
                
                if data.get("status") == "failed" or data.get("error"):
                    error_msg = data.get("error", "Unknown provider error")
                    logger.error(f"NanoBanana API reported failure: {error_msg}")
                    raise ValueError(f"Generation failed: {error_msg}")

                if not image_url:
                    logger.error(f"NanoBanana API response missing 'url': {data}")
                    raise ValueError("Invalid response from NanoBanana API: missing 'url'")
                
                logger.info(f"Successfully generated image: {image_url}")
                return str(image_url)
                
            except httpx.HTTPStatusError as e:
                logger.error(f"NanoBanana API error: {e.response.status_code} - {e.response.text}")
                raise
            except Exception as e:
                logger.error(f"Unexpected error calling NanoBanana API: {e}")
                raise

class ImagenV2Provider(VisualProvider):
    """
    Implementation of VisualProvider for the Imagen API v2.0 (Port 8009).
    Supports asynchronous generation with polling.
    """
    def __init__(self, api_key: str | None = None, base_url: str | None = None):
        """
        Initialize the ImagenV2 provider.
        
        Args:
            api_key: API key for authentication. Defaults to IMAGENV2_API_KEY env var.
            base_url: Base URL for Imagen API. Defaults to IMAGENV2_BASE_URL env var or port 8009.
        """
        self.api_key = api_key or os.getenv("IMAGENV2_API_KEY")
        self.base_url: str = str(base_url or os.getenv("IMAGENV2_BASE_URL", "http://localhost:8009"))
        
        logger.info(f"ImagenV2Provider initialized with base_url: {self.base_url}")

    async def generate(self, prompt: str, reference_image: str | None = None, **kwargs: Any) -> str:
        """
        Generate an image using the Imagen API v2.0.
        Performs asynchronous polling until the image is ready.
        """
        base_endpoint = self.base_url.rstrip('/')
        generate_endpoint = f"{base_endpoint}/generate"
        
        # Load defaults from environment
        default_model = os.getenv("IMAGENV2_MODEL", "sdxl")
        default_guidance = float(os.getenv("IMAGENV2_GUIDANCE_SCALE", "7.5"))
        
        env_loras_str = os.getenv("IMAGENV2_LORAS", "[]")
        try:
            default_loras = json.loads(env_loras_str)
            if not isinstance(default_loras, list):
                logger.warning("IMAGENV2_LORAS must be a JSON list. Using empty list.")
                default_loras = []
        except json.JSONDecodeError:
            logger.warning(f"Invalid JSON in IMAGENV2_LORAS: {env_loras_str}. Using empty list.")
            default_loras = []

        default_ip_strength = float(os.getenv("IMAGENV2_IP_STRENGTH", "0.7"))

        # Prepare payload for v2.0 API
        payload = {
            "prompt": prompt,
            "negative_prompt": kwargs.get("negative_prompt"),
            "model": kwargs.get("model", default_model),
            "loras": kwargs.get("loras", default_loras),
            "steps": kwargs.get("steps", 30),
            "guidance_scale": kwargs.get("guidance_scale", default_guidance),
            "seed": kwargs.get("seed"),
            "ip_strength": kwargs.get("ip_strength", 0.0)
        }
        
        if reference_image:
            # v2 API uses ip_strength for style transfer from reference
            payload["ip_strength"] = kwargs.get("ip_strength", default_ip_strength)
            payload["reference_image"] = reference_image
            
        # Add any other kwargs to payload for future-proofing
        for key, value in kwargs.items():
            if key not in payload:
                payload[key] = value

        headers = {
            "Authorization": f"Bearer {self.api_key}" if self.api_key else "",
            "Content-Type": "application/json"
        }

        async with httpx.AsyncClient() as client:
            try:
                # 1. Start generation
                safe_payload = payload.copy()
                if "reference_image" in safe_payload:
                    safe_payload["reference_image"] = f"[BASE64_DATA:{len(safe_payload['reference_image'])} chars]"
                
                logger.info(f"IMAGENV2_START: {json.dumps(safe_payload, indent=2)}")
                
                response = await client.post(generate_endpoint, json=payload, headers=headers, timeout=30.0)
                response.raise_for_status()
                
                gen_data = response.json()
                job_id = gen_data.get("job_id")
                
                if not job_id:
                    logger.error(f"ImagenV2 API response missing 'job_id': {gen_data}")
                    raise ValueError("Invalid response from ImagenV2 API: missing 'job_id'")
                
                logger.info(f"IMAGENV2_QUEUED: Job ID {job_id}")

                # 2. Polling for results
                image_endpoint = f"{base_endpoint}/image/{job_id}"
                max_retries = 120  # 120 * 5s = 10 minutes (matching API timeout)
                
                for attempt in range(max_retries):
                    img_response = await client.get(image_endpoint, headers=headers, timeout=30.0)
                    
                    if img_response.status_code == 200:
                        # Image is ready!
                        logger.info(f"IMAGENV2_SUCCESS: Job {job_id} complete.")
                        
                        # Save binary content to temp file
                        fd, path = tempfile.mkstemp(suffix=".png")
                        with os.fdopen(fd, "wb") as tmp:
                            tmp.write(img_response.content)
                        
                        return f"file://{path}"
                    
                    elif img_response.status_code == 202:
                        # Still processing
                        progress_data = img_response.json()
                        state = progress_data.get("state", "UNKNOWN")
                        progress = progress_data.get("meta", {}).get("progress", 0)
                        logger.debug(f"IMAGENV2_PROGRESS: Job {job_id} is {state} ({progress}%)")
                        await asyncio.sleep(5)
                        
                    elif img_response.status_code == 500:
                        # Server error or generation failure
                        error_data = img_response.json()
                        error_msg = error_data.get("detail", {}).get("error", "Unknown server error")
                        logger.error(f"IMAGENV2_FAILURE: Job {job_id} failed: {error_msg}")
                        raise ValueError(f"Generation failed: {error_msg}")
                    
                    else:
                        img_response.raise_for_status()
                
                raise TimeoutError(f"ImagenV2 generation timed out after {max_retries * 5} seconds")
                
            except httpx.HTTPStatusError as e:
                logger.error(f"ImagenV2 API error: {e.response.status_code} - {e.response.text}")
                raise
            except Exception as e:
                logger.error(f"Unexpected error calling ImagenV2 API: {e}")
                raise
